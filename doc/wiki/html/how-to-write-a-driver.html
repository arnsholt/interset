<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cs"
 lang="cs" dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>user:zeman:interset:how-to-write-a-driver [ufal wiki]</title>
	<meta name="generator" content="DokuWiki Release 2006-11-06" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2008-03-14T12:16:00+0100" />
<meta name="keywords" content="user,zeman,interset,how-to-write-a-driver" />
<link rel="start" href="/" />
<link rel="contents" href="/user:zeman:interset:how-to-write-a-driver?do=index" title="Index" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="/feed.php" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="/feed.php?mode=list&amp;ns=user:zeman:interset" />
<link rel="alternate" type="text/html" title="Plain HTML" href="/_export/xhtml/user:zeman:interset:how-to-write-a-driver" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="/_export/raw/user:zeman:interset:how-to-write-a-driver" />
<link rel="stylesheet" media="screen" type="text/css" href="/lib/exe/css.php?1" />
<link rel="stylesheet" media="print" type="text/css" href="/lib/exe/css.php?print=1" />
<script type="text/javascript" charset="utf-8" src="/lib/exe/js.php?edit=0&amp;write=0" ></script>
	<link href="ufal.css" rel="stylesheet" type="text/css" media="screen" />
	<!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="ufal-msie.css" media="screen" /><![endif]-->
	<!--[if IE 7]><link rel="stylesheet" type="text/css" href="ufal-msie7.css" media="screen" /><![endif]-->
  	<link href="print.css" rel="stylesheet" media="print" />
  	<link rel="shortcut icon" href="/lib/tpl/ufal/images/favicon.ico" />
</head>


<body>
  <p class="hiddenWithCss">
		<a href="user:zeman:interset:how-to-write-a-driver#" id="noCssNavigation"></a>
		[ <a href="user:zeman:interset:how-to-write-a-driver#noCssContent">Skip to the content</a> ]
	</p>
	<div>
		<a href="index.html"><img id="logo" src="logo_ufal_142.png" alt="MFF ÚFAL Wiki" /></a>
	</div>

	<h1 class="header"><a href="index.html">Institute of Formal and Applied Linguistics Wiki</a></h1>

	<ul id="menu">
		<li><a href="index.html" class="active">ÚFAL Wiki Home</a></li>
		<li><a href="http://ufal.ms.mff.cuni.cz">ÚFAL Home</a></li>
				<!--li><a title="spravuje Dan Zeman" href="/cgi-bin/zeman/adresy/index.pl">Kontakty</a></li-->
		<li><a title="přehled všech stránek" href="doku.php?do=index">Sitemap</a></li>
		<li><a title="přehled změn" href="feed.php">RSS</a></li>
		<li style="margin-bottom:2em;"><a title="ufal.kalendar" href="kalendar">ÚFAL kalendář</a></li>

						<li><a href="index.html?do=recent">Poslední změny stránek</a></li>
		 <li><a href="https://wiki.ufal.ms.mff.cuni.cz/user:zeman:interset:how-to-write-a-driver?do=revisions">Starší verze této stránky</a></li> 		 <li><a href="https://wiki.ufal.ms.mff.cuni.cz/doku.php?do=login&amp;id=user:zeman:interset:how-to-write-a-driver">Přihlášení</a></li> 		
	<li>
	Hledat:
	<form method="get" action="/doku.php">
	<input type="hidden" name="do" value="search"/>
	<input type="text" name="id" size="12" style="width:10em!important; font-size:97%" />
	</form>
	</li>

	</ul>


	<hr class="hiddenWithCss" />

	<p class="hiddenWithCss">
		<a href="user:zeman:interset:how-to-write-a-driver#" id="noCssContent"></a>
		[ <a href="user:zeman:interset:how-to-write-a-driver#noCssNavigation">Back to the navigation</a> ]
	</p>

		<div class="breadcrumbs">
    	Umístění: <a href="start"  title="start">start</a> &raquo; <a href="user"  title="user">user</a> &raquo; <a href="user:zeman:start"  title="user:zeman:start">zeman</a> &raquo; <a href="user:zeman:interset"  title="user:zeman:interset">interset</a> &raquo; <a href="user:zeman:interset:how-to-write-a-driver"  title="user:zeman:interset:how-to-write-a-driver">how-to-write-a-driver</a>    </div>
    
	<div id="main" class="dokuwiki">
								<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Obsah</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#how-to-write-a-driver" class="toc">How to write a driver</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#decode" class="toc">decode()</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#encode" class="toc">encode()</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#list" class="toc">list()</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#alternative-values" class="toc">Alternative values</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#replacing-feature-values-with-defaults" class="toc">Replacing feature values with defaults</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#replacing-whole-feature-structures-with-defaults" class="toc">Replacing whole feature structures with defaults</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#common-problems" class="toc">Common problems</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="user:zeman:interset:how-to-write-a-driver#test-your-driver" class="toc">Test your driver</a></span></div></li></ul>
</li></ul>
</div>
</div>



<h1><a name="how-to-write-a-driver" id="how-to-write-a-driver">How to write a driver</a></h1>
<div class="level1">

<p>
 <acronym title="Practical Extraction and Report Language">Perl</acronym> is the language to write a driver. A driver is a simple <acronym title="Practical Extraction and Report Language">Perl</acronym> module (.pm). It should implement the following functions: <code>decode()</code>, <code>encode()</code>, <code>list()</code>. The <code>tagset/common.pm</code> module contains some code you may have use for, so your driver module should start with 
</p>
<pre class="code perl"><span class="kw2">use</span> tagset::<span class="me2">common</span>;</pre>
<p>
The input/output tag can be any string. If the information is stored in several kinds of tags, they can be passed in one string, using some unique delimiters. We recommend &quot;\t&quot; (horizontal tab, <acronym title="American Standard Code for Information Interchange">ASCII</acronym> 9) as delimiter. If desirable, the input/output tag can be even a multi-line <acronym title="Extensible Markup Language">XML</acronym>
<dl>
<dd> </dd>
</dl>
 Empty feature value means &quot;unknown&quot;. It is even not known, whether this feature would be relevant. Some tagsets distinguish between unknown values and irrelevant features. This is not the case of Interset. While something can be irrelevant in one tagset, we can hardly say that it is not relevant in any tagset. So, since we are setting a value in a universal &quot;tagset&quot;, we probably better leave the value empty or even set it to an appropriate default. 
</p>

</div>

<h2><a name="decode" id="decode">decode()</a></h2>
<div class="level2">

<p>
 This function has one string argument, the tag. The function returns a reference to a hash of features (feature names are hash keys to the feature values). 
</p>

<p>
The decoder is not obliged to set any feature. If the decoder decides to set a feature, it should be one of the pre-defined values. This can be checked by a central procedure. However, it is not mandatory, so if the appropriate value is not available, you can use your own, but please do <strong><a href="mailto:&#x7a;&#x65;&#x6d;&#x61;&#x6e;&#x40;&#x75;&#x66;&#x61;&#x6c;&#x2e;&#x6d;&#x66;&#x66;&#x2e;&#x63;&#x75;&#x6e;&#x69;&#x2e;&#x63;&#x7a;" class="mail JSnocheck" title="&#x7a;&#x65;&#x6d;&#x61;&#x6e;&#x40;&#x75;&#x66;&#x61;&#x6c;&#x2e;&#x6d;&#x66;&#x66;&#x2e;&#x63;&#x75;&#x6e;&#x69;&#x2e;&#x63;&#x7a;">let me know</a></strong> so I can update the <a href="user:zeman:interset:features" class="wikilink1" title="user:zeman:interset:features">central value pool</a> accordingly. (If you set a value that is not documented as a part of the universal set, no one else can benefit from it. If you combine your driver with another driver to convert from your tag set to the other, the other driver's encode() will not take your invented value into account. It may even behave worse than if the value was empty.) 
</p>

<p>
If the tagset encodes features separately (e.g., each character is a value of a particular feature): The decoder should be tolerant to unexpected combinations of features (or should be able to be tolerant if asked for it). 
</p>

</div>

<h2><a name="encode" id="encode">encode()</a></h2>
<div class="level2">

<p>
 This function has one argument, a reference to a hash of features (feature names are hash keys to the feature values). The function returns a string - the tag. 
</p>

<p>
The encoder should be able to process all possible values from the <a href="user:zeman:interset:features" class="wikilink1" title="user:zeman:interset:features">central pool</a>. If the tagset does not recognize a value, the most appropriate substitute should be chosen. 
</p>

<p>
Since any feature can in theory have an array of values instead of a single value, the encoder should either be prepared to arrays (more precisely: array references) anywhere, or call <code>tagset::single_values()</code> to get rid of the arrays (or some of them). See <a href="user:zeman:interset:how-to-write-a-driver#alternative-values" title="user:zeman:interset:how-to-write-a-driver &crarr;" class="wikilink1">Alternative values</a> for more details. 
</p>

<p>
<strong>WARNING:</strong> Before modifying the contents of the feature structure, you should make a <em>deep</em> copy of it. You cannot assume that the user of the driver will not need the original values of the features after encoding. If you have called <code>single_values()</code>, it made the copy for you. 
</p>

</div>

<h2><a name="list" id="list">list()</a></h2>
<div class="level2">

<p>
 The list() function returns a reference to an array of all plausible tags in the set. Undefined return value means no list is available and thus any tag is plausible. If there is a list, strict encoding should conform to it. 
</p>

<p>
The list is not necessary for the driver to work. However, it can be useful for <a href="user:zeman:interset:how-to-write-a-driver#test-your-driver" title="user:zeman:interset:how-to-write-a-driver &crarr;" class="wikilink1">testing</a> the driver. If no list is distributed along with the tagset description, you may still be able to acquire a partial list from a corpus. 
</p>

</div>

<h2><a name="alternative-values" id="alternative-values">Alternative values</a></h2>
<div class="level2">

<p>
 A feature can have two or more alternative values at the same time. This may be necessary because some tags in some tagsets are defined that way. For instance, the character <code>H</code> on position 8 in the <acronym title="Prague Dependency Treebank">PDT</acronym> Czech tagset means &quot;tense = past or present.&quot; Alternative values are represented by a single reference to an array of values. 
</p>

<p>
The corresponding <code>decode()</code> code may look like this: 
</p>
<pre class="code perl"><span class="kw1">elsif</span><span class="br0">&#40;</span><span class="re0">$tense</span> eq <span class="st0">&quot;H&quot;</span><span class="br0">&#41;</span> 
<span class="br0">&#123;</span> 
    <span class="re0">$f</span><span class="br0">&#123;</span>tense<span class="br0">&#125;</span> = <span class="br0">&#91;</span><span class="st0">&quot;past&quot;</span>, <span class="st0">&quot;pres&quot;</span><span class="br0">&#93;</span>; 
<span class="br0">&#125;</span></pre>
<p>
Note that every <code>encode()</code> implementation should be prepared to work with multiple values of features! Even if your own driver does not create arrays in <code>decode()</code>, you should be able to deal with arrays coming from other tagsets. However, if you do not create arrays, your tagset is probably not capable of storing alternative feature values and you cannot do much more than just pick the first value from the array and use it. In that case it is annoying to have to check for arrays in every single feature. Fortunately, you can get rid of all arrays at once by calling the <code>single_values()</code> function at the beginning of your <code>encode()</code>: 
</p>
<pre class="code perl"><span class="kw2">use</span> tagset; 
<span class="kw2">sub</span> encode 
<span class="br0">&#123;</span> 
    <span class="kw1">my</span> <span class="re0">$f</span> = <a href="http://www.perldoc.com/perl5.6/pod/func/shift.html"><span class="kw3">shift</span></a>; 
    <span class="co1"># Replace any array values by single values. </span>
    <span class="kw1">my</span> <span class="re0">$single</span> = tagset::<span class="me2">single_values</span><span class="br0">&#40;</span><span class="re0">$f</span>, <span class="st0">&quot;gender&quot;</span>, <span class="st0">&quot;animateness&quot;</span>, <span class="st0">&quot;number&quot;</span>, <span class="st0">&quot;tense&quot;</span><span class="br0">&#41;</span>; 
    <span class="kw1">my</span> <span class="re0">%f</span> = %<span class="br0">&#123;</span><span class="re0">$single</span><span class="br0">&#125;</span>;</pre>
<p>
The <code>single_values()</code> function will replace any array by its first member value. Note that you can specify features that are exceptions to this rule. In the above example, the features <code>gender</code>, <code>animateness</code>, <code>number</code> and <code>tense</code> will retain multiple values, if present. Thus if you are able to deal with arrays, this is the way how you specify where you can do so and where you cannot. 
</p>

<p>
Now, what do you do with features where you want to encode arrays? You should first check whether the value is an array or not. If it is an array, you may want to <code>grep</code> your values rather than trying exact match, because you do not know what is going to come from other drivers, and the ordering or additional values may not be what matters. 
</p>

<p>
If the array turns out to be incompatible with what you expect, you should pick one value (we suggest you  take the first one) and proceed with default single-value processing. 
</p>
<pre class="code perl">    <span class="kw1">if</span><span class="br0">&#40;</span><a href="http://www.perldoc.com/perl5.6/pod/func/ref.html"><span class="kw3">ref</span></a><span class="br0">&#40;</span><span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span><span class="br0">&#41;</span> eq <span class="st0">&quot;ARRAY&quot;</span><span class="br0">&#41;</span> 
    <span class="br0">&#123;</span> 
        <span class="co1"># Processing of any combined values goes here. </span>
        <span class="kw1">my</span> <span class="re0">@values</span> = @<span class="br0">&#123;</span><span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span><span class="br0">&#125;</span>; 
        <span class="kw1">if</span><span class="br0">&#40;</span><a href="http://www.perldoc.com/perl5.6/pod/func/scalar.html"><span class="kw3">scalar</span></a><span class="br0">&#40;</span><a href="http://www.perldoc.com/perl5.6/pod/func/grep.html"><span class="kw3">grep</span></a><span class="br0">&#123;</span><a href="http://www.perldoc.com/perl5.6/pod/func/m.html"><span class="kw3">m</span></a>/^masc$/<span class="br0">&#125;</span><span class="br0">&#40;</span><span class="re0">@values</span><span class="br0">&#41;</span><span class="br0">&#41;</span> &amp;&amp; 
           <a href="http://www.perldoc.com/perl5.6/pod/func/scalar.html"><span class="kw3">scalar</span></a><span class="br0">&#40;</span><a href="http://www.perldoc.com/perl5.6/pod/func/grep.html"><span class="kw3">grep</span></a><span class="br0">&#123;</span><a href="http://www.perldoc.com/perl5.6/pod/func/m.html"><span class="kw3">m</span></a>/^fem$/<span class="br0">&#125;</span><span class="br0">&#40;</span><span class="re0">@values</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> 
        <span class="br0">&#123;</span> 
            <span class="re0">$tag</span><span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span> = <span class="st0">&quot;T&quot;</span>; 
        <span class="br0">&#125;</span> 
        <span class="kw1">elsif</span><span class="br0">&#40;</span>...<span class="br0">&#41;</span> 
        <span class="br0">&#123;</span> 
            ... 
        <span class="br0">&#125;</span> 
        <span class="kw1">else</span> 
        <span class="br0">&#123;</span> 
            <span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span> = <span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span><span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>; 
        <span class="br0">&#125;</span> 
    <span class="br0">&#125;</span> 
    <span class="kw1">if</span><span class="br0">&#40;</span><a href="http://www.perldoc.com/perl5.6/pod/func/ref.html"><span class="kw3">ref</span></a><span class="br0">&#40;</span><span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span><span class="br0">&#41;</span> eq <span class="st0">&quot;&quot;</span><span class="br0">&#41;</span> 
    <span class="br0">&#123;</span> 
        <span class="kw1">if</span><span class="br0">&#40;</span><span class="re0">$f</span><span class="br0">&#123;</span>gender<span class="br0">&#125;</span> eq <span class="st0">&quot;masc&quot;</span><span class="br0">&#41;</span> 
        <span class="br0">&#123;</span> 
            ...</pre>
<p>
<strong>Note:</strong> This approach cannot encode situations where some combinations of feature values are plausible and some are not! For instance, if positions [2] and [3] in a tag encode gender and number, respectively, and if <code>NNQW</code> means a logical disjunction of the tags <code>NNFS</code> and <code>NNNP</code>, then you cannot encode the situation in <acronym title="Daniel Zeman">DZ</acronym> Interset precisely. If you do not want to discard either <code>NNFS</code> or <code>NNNP</code> (by storing the other only), you can say that gender = <code>F</code> or <code>N</code> and number = <code>S</code> or <code>P</code> but by that you have also introduced <code>NNFP</code> and <code>NNNS</code> as possibilities. The approach may be revised in future. 
</p>

</div>

<h2><a name="replacing-feature-values-with-defaults" id="replacing-feature-values-with-defaults">Replacing feature values with defaults</a></h2>
<div class="level2">

<p>
 The encoder's problem is that there are more feature values on input than can be encoded on output. If a value cannot be encoded, the encoder must replace it with a suitable default. Although it can control the replacement completely by its own means (e.g. by a system of <code>if</code>-<code>else</code> statements), there is a central system of defaults that can take care of it. The central system however needs the following:  
</p>
<ol>
<li class="level1"><div class="li"> A table of replacement values for each value, ordered by precedence. There is a default table in <code>tagset::common</code>. A driver can supply its own, if needed. </div>
</li>
<li class="level1"><div class="li"> The list of all tags in the tag set (implemented by the <code>list()</code> driver function). Then the central system will return the highest-priority <em>permitted</em> value. A value is permitted if the tag set contains a tag that yields the value when decoded. </div>
</li>
</ol>

<p>
 Building the list of permitted values is expensive (all tags must be decoded!) and you should do it only once when your driver initializes. In your <code>BEGIN</code> block, you should call <code>tagset::common::get_permitted_values()</code> and store the hash reference it returns. The hash (of arrays) will contain a list of permitted values for every feature. When you later need to check a value and replace it if necessary, you pass the hash reference back to <code>tagset::common</code>: 
</p>

<p>
(Note that the <code>list()</code> function must be defined before the <code>BEGIN</code> block that uses it.) 
</p>
<pre class="code perl"><span class="kw2">use</span> tagset::<span class="me2">common</span>; 
... 
<span class="kw2">sub</span> list <span class="br0">&#123;</span> ... <span class="br0">&#125;</span> 
... 
<span class="kw2">BEGIN</span> 
<span class="br0">&#123;</span> 
    <span class="co1"># Store the hash reference in a global variable. </span>
    <span class="re0">$permitvals</span> = tagset::<span class="me2">common</span>::<span class="me2">get_permitted_values</span><span class="br0">&#40;</span>list<span class="br0">&#40;</span><span class="br0">&#41;</span>, \&amp;decode<span class="br0">&#41;</span>; 
<span class="br0">&#125;</span> 
... 
<span class="re0">$replacement</span> = tagset::<span class="me2">common</span>::<span class="me2">check_value</span><span class="br0">&#40;</span><span class="re0">$feature</span>, <span class="re0">$value</span>, <span class="re0">$permitvals</span><span class="br0">&#41;</span>;</pre>
<p>
Alternatively, the following checks <strong>and replaces</strong> values of all features in a feature structure: 
</p>
<pre class="code perl">tagset::<span class="me2">common</span>::<span class="me2">enforce_permitted_values</span><span class="br0">&#40;</span><span class="re0">$fstruct</span>, <span class="re0">$permitvals</span><span class="br0">&#41;</span>;</pre>
<p>
If an array is a permitted value, all member values are permitted. 
</p>

<p>
If an array is checked, all member values must be permitted in order for the array to be permitted. Otherwise, the array is pruned and the replacement is a subarray where only permitted values are kept. If no member values are permitted (hence the pruned subarray would be empty), the replacement is a single value, the highest-priority replacement of the first element of the array. If the original array was empty (which should never happen but we ought to be careful anyway), the single empty value is checked and possibly replaced. 
</p>

</div>

<h2><a name="replacing-whole-feature-structures-with-defaults" id="replacing-whole-feature-structures-with-defaults">Replacing whole feature structures with defaults</a></h2>
<div class="level2">

<p>
 The above technique does not guarantee that the encoder will only see feature <em>combinations</em> that it normally gets from its own decoder. For instance, the <code>case</code> feature may be known in the given tagset but it only occurs with nouns. When encoding features produced by a different driver, there could be non-empty case also for adjectives, pronouns etc. Even though the encoder may be able to encode the new feature combination (using the tagset's usual way of expressing the values &quot;adjective&quot; and, say, &quot;genitive&quot;) it is not always desirable (depending on the application) to invent new tags. Default encoding should be <strong>strict,</strong> meaning that only the tags returned by <code>list()</code> can be returned by the encoder. 
</p>

<p>
Similarly to the replacement of separate values, the encoder can ask the Interset common library to replace the whole structure by something the encoder is used to (i.e. by a structure that results from decoding of a tag known by the driver). This usually removes from the encoder the burden of thinking about exotic features and values. 
</p>

<p>
The correcting function tries to lie as little as possible. There is a priority value associated with every known feature. Feature values are checked (and possibly altered) in the order of feature priorities. In the above example (adjective cannot have case), the part of speech would keep its &quot;adjective&quot; value, and the case value would be removed. If the case feature had higher priority than the pos feature (which is not the case), a non-empty value of <code>case</code> would force part of speech to be changed from adjective to noun. 
</p>
<pre class="code perl"><span class="kw2">use</span> tagset::<span class="me2">common</span>; 
... 
<span class="kw2">sub</span> list <span class="br0">&#123;</span> ... <span class="br0">&#125;</span> 
... 
<span class="kw2">BEGIN</span> 
<span class="br0">&#123;</span> 
    <span class="co1"># Store the hash reference in a global variable. </span>
    <span class="re0">$permitted</span> = tagset::<span class="me2">common</span>::<span class="me2">get_permitted_structures_joint</span><span class="br0">&#40;</span>list<span class="br0">&#40;</span><span class="br0">&#41;</span>, \&amp;decode<span class="br0">&#41;</span>; 
<span class="br0">&#125;</span> 
... 
<span class="co1"># Give reference to feature structure. Get reference to a new one (deep copy). </span>
<span class="re0">$fs1</span> = tagset::<span class="me2">common</span>::<span class="me2">enforce_permitted_joint</span><span class="br0">&#40;</span><span class="re0">$fs0</span>, <span class="re0">$permitted</span><span class="br0">&#41;</span>;</pre>
</div>

<h2><a name="common-problems" id="common-problems">Common problems</a></h2>
<div class="level2">

<p>
 See <a href="user:zeman:interset:common-problems" class="wikilink1" title="user:zeman:interset:common-problems">Common Problems</a> for a list of suggestions for phenomena difficult to match between tagsets and the Interset. 
</p>

</div>

<h2><a name="test-your-driver" id="test-your-driver">Test your driver</a></h2>
<div class="level2">

<p>
 When you have written a driver for a new tagset, you should test it. The driver package contains a test script called <code>driver-test.pl</code>. When running it, give the driver name as argument, without the <code>tagset::</code> prefix. You can also use the <code>-d</code> option to turn on debug messages (list of tags being tested). 
</p>
<pre class="code">driver-test.pl ar::conll 
driver-test.pl bg::conll cs::pdt 
driver-test.pl -a 
driver-test.pl -A</pre>

<p>
Running <code>driver-test.pl</code> without arguments will list the drivers available on the system. Two (or more) arguments test both drivers separately and then conversions from driver A to driver B and vice versa. Running it with the <code>-a</code> option will test all the drivers but no conversions. The <code>-A</code> option tests all drivers and all conversions between all pairs of drivers. 
</p>

<p>
Note that only drivers implementing the <code>list()</code> function can be tested. Most testing involves generating the list of all possible tags and testing the driver on each tag separately. 
</p>

<p>
The following tests will be performed for a single driver:  
</p>
<ul>
<li class="level1"><div class="li"> Decode each tag and check that only known features and values are set. In addition to a built-in list, every feature can have an empty value, and the features &quot;tagset&quot; and &quot;other&quot; can have any value. </div>
</li>
<li class="level1"><div class="li"> Check for each tag that <code>encode(decode($tag)) eq $tag</code>. While sometimes it can be annoying to try to preserve some obscure information hidden in the tags, this test can also reveal many unwanted bugs. Besides, you should preserve information of your own tagset because people may want to use your driver merely to <em>access</em> the tags, instead of <em>converting</em> them. </div>
</li>
</ul>

<p>
 The following tests will be performed for a pair of drivers:  
</p>
<ul>
<li class="level1"><div class="li"> Decode every tag of the first driver, encode it using the second driver and check whether the result is a known tag in the second tagset. </div>
</li>
</ul>

<p>
 <br />
</p>

</div>

					</div> <!-- dokuwiki div end -->

	<hr class="hiddenWithCss" />

    <p class="hiddenWithCss">
      [ <a href="user:zeman:interset:how-to-write-a-driver#noCssNavigation">Back to the navigation</a> ]
      [ <a href="user:zeman:interset:how-to-write-a-driver#noCssContent">Back to the content</a> ]
    </p>

	<div class="no"><img src="/lib/exe/indexer.php?id=user%3Azeman%3Ainterset%3Ahow-to-write-a-driver&amp;1235066236" width="1" height="1" alt=""  /></div>
</body>
</html>
