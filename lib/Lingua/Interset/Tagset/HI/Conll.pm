# ABSTRACT: Driver for the Hindi tagset of the ICON 2009 and 2010 Shared Tasks, as used in the CoNLL data format.
# Documentation:
# http://ltrc.iiit.ac.in/nlptools2010/documentation.php
# http://ltrc.iiit.ac.in/MachineTrans/publications/technicalReports/tr031/posguidelines.pdf
# Copyright © 2011 Loganathan Ramasamy <ramasamy@ufal.mff.cuni.cz>
# Copyright © 2011, 2014 Dan Zeman <zeman@ufal.mff.cuni.cz>

package Lingua::Interset::Tagset::HI::Conll;
use strict;
use warnings;
# VERSION: generated by DZP::OurPkgVersion

use utf8;
use open ':utf8';
use namespace::autoclean;
use Moose;
extends 'Lingua::Interset::Tagset';



has 'atoms' => ( isa => 'HashRef', is => 'ro', builder => '_create_atoms', lazy => 1 );



#------------------------------------------------------------------------------
# Returns the tagset id that should be set as the value of the 'tagset' feature
# during decoding. Every derived class must (re)define this method! The result
# should correspond to the last two parts in package name, lowercased.
# Specifically, it should be the ISO 639-2 language code, followed by '::' and
# a language-specific tagset id. Example: 'cs::multext'.
#------------------------------------------------------------------------------
sub get_tagset_id
{
    return 'hi::conll';
}



#------------------------------------------------------------------------------
# Creates atomic drivers for surface features.
#------------------------------------------------------------------------------
sub _create_atoms
{
    my $self = shift;
    my %atoms;
    # PART OF SPEECH ####################
    $atoms{pos} = $self->create_atom
    (
        'surfeature' => 'pos',
        'decode_map' =>
        {
            # These tags come in the POS column of the CoNLL data format (while CPOS contains so-called chunk tag).
            # Many tags come in two flavors, with and without final 'C'. The 'C' means "compound". Nevertheless, the compounds do not occur in the current data.
            # Documentation contains many tags that do not occur in actual data. The following tags have been observed in the data:
            # NN (4924), VM (2854), NNP (1540), PRP (1096), JJ (536), CC (448), NULL (388), NST (332), SYM (252), RB (230), WQ (110),
            # RP (96), QF (20), QC (16), INJ (14), NEG (6), VAUX (6), DEM (4), XC (4), PSP (2), RDP (2)
            # common nouns
            # Examples:
            # কথা (kathā = word), বাতাসে (bātāsē = air), সময় (samaẏa = time), স্যার (syāra = sir), হাত (hāta = hand)
            'NN'   => ['pos' => 'noun', 'nountype' => 'com'],
            'NNC'  => ['pos' => 'noun', 'nountype' => 'com'],
            # proper nouns
            # Examples:
            # সালে (Sālē), খ্রী (Khrī = America), মদনা (Madanā), গণপতিবাবু (Gaṇapatibābu), কলকাতা (Kalakātā = Kolkata)
            'NNP'  => ['pos' => 'noun', 'nountype' => 'prop'],
            'NNPC' => ['pos' => 'noun', 'nountype' => 'prop'],
            # location nouns
            # These words are grammatically nouns but they are used to form a sort of postpositions. Often but not always they specify location.
            # For instance, "on the table" would be constructed as "the table's upper side", and the word for "upper side" would be tagged NST.
            # Examples:
            # সঙ্গে (saṅgē = with), উপর (upara = up, on), কাছে (kāchē = of), মধ্যে (madhyē = in, between), পর (para = after)
            'NST'  => ['pos' => 'noun', 'adpostype' => 'post'],
            'NSTC' => ['pos' => 'noun', 'adpostype' => 'post'],
            # pronouns
            # Examples (note that the "possessive" pronouns are genitive forms of personal pronouns):
            # তার (tāra = his), আমি (āmi = I), আমার (āmāra = my), এখন (ēkhana = now), সে (sē = he)
            'PRP'  => ['pos' => 'noun', 'prontype' => 'prs'],
            'PRPC' => ['pos' => 'noun', 'prontype' => 'prs'],
            # question words
            # Examples:
            # কি (ki = what), কী (kī = what), কেন (kēna = why), কোথায় (kōthāẏa = where), কে (kē = who)
            'WQ'   => ['pos' => 'noun', 'prontype' => 'int'],
            # adjectives
            # Examples:
            # পরিণত (pariṇata = become, turned [participle]), বাধ্য (bādhya = forced), ভালো (bhālō = good), দুর্বল (durbala = weak)
            'JJ'   => ['pos' => 'adj'],
            'JJC'  => ['pos' => 'adj'],
            # demonstratives
            # Only 4 occurrences in the corpus, only 2 word types:
            # এই (ē'i = this), এইসব (ē'isaba = these)
            'DEM'  => ['pos' => 'adj', 'prontype' => 'dem'],
            # quantifiers
            # Examples:
            # একটু (ēkaṭu = a little), কিছুটা (kichuṭā = somewhat), কোনও (kōna'ō = no), খুব (khuba = very), বহু (bahu = many), সব (saba = all)
            'QF'   => ['pos' => 'adj', 'prontype' => 'ind'],
            'QFC'  => ['pos' => 'adj', 'prontype' => 'ind'],
            # numerals
            # Examples:
            # ১৬৯৮ (1698), ১৮৯ (189), এক (ēka = one), সতের (satēra = seventeen), হাজার (hājāra = thousand)
            'QC'   => ['pos' => 'num', 'numtype' => 'card'],
            'QCC'  => ['pos' => 'num', 'numtype' => 'card'],
            'QO'   => ['pos' => 'adj', 'numtype' => 'ord'],
            # main verbs (documentation says "verb-finite", are they really always finite forms?)
            # Examples:
            # করে (karē = do), হয় (haẏa = be), হয়ে (haẏē = be), ছিল (chila = was), করতে (karatē = do)
            'VM'   => ['pos' => 'verb'],
            'VMC'  => ['pos' => 'verb'],
            # auxiliary verbs
            # Only three occurrences in the corpus:
            # চায় (cāẏa = want), নেবেন (nēbēna = will), যায় (yāẏa = can)
            'VAUX' => ['pos' => 'verb', 'verbtype' => 'aux'],
            # adverbs
            # Examples:
            # শুধু (śudhu = only), তারপর (tārapara = then), আর (āra), আবার (ābāra = again), ক্রমে (kramē = gradually)
            'RB'   => ['pos' => 'adv'],
            'RBC'  => ['pos' => 'adv'],
            # intensifiers
            'INTF' => ['pos' => 'adv'],
            # negation
            # Example:
            # না (nā = not)
            'NEG'  => ['pos' => 'part', 'prontype' => 'neg', 'negativeness' => 'neg'],
            # postpositions
            # Examples:
            # সহ (saha = with)
            'PSP'  => ['pos' => 'adp', 'adpostype' => 'post'],
            # conjunctions
            # Examples:
            # ও (ō = and), এবং (ēbaṁ = and), কিন্তু (kintu = but), আর (āra = and), বা (bā = or)
            'CC'   => ['pos' => 'conj'],
            'UT'   => ['pos' => 'conj', 'conjtype' => 'sub'],
            # particles
            # Examples:
            # তো (tō), করে (karē), যেন (yēna), আর (āra), যে (yē)
            'RP'   => ['pos' => 'part'],
            # interjections
            # Examples:
            # আচ্ছা (ācchā = well), কি (ki = what), খিলখিল (khilakhila = haha), ছি (chi = bo), ত (ta)
            'INJ'  => ['pos' => 'int'],
            # reduplicatives
            # Only one occurrence in the corpus:
            # যার (yāra)
            'RDP'  => ['echo' => 'rdp'],
            # echo words
            'ECH'  => ['echo' => 'ech'],
            # undocumented (compounds???), two word forms, four occurrences:
            # টুকরো (Ṭukarō = Trivia), যে (yē = that)
            'XC'   => [],
            # punctuation
            # Examples (the corpus contains European punctuation):
            # , . - " ? ; : !
            'SYM'  => ['pos' => 'punc'],
            # foreign or unknown words
            'UNK'  => ['foreign' => 'foreign'],
            # The 'NULL' tag is used for artificial NULL nodes.
            'NULL' => ['other' => {'pos' => 'null'}]
        },
        'encode_map' =>

            { 'pos' => { 'noun' => { 'adpostype' => { 'post' => 'NST',
                                                      '@'    => { 'prontype' => { ''    => { 'nountype' => { 'prop' => 'NNP',
                                                                                                             '@'    => 'NN' }},
                                                                                  'int' => 'WQ',
                                                                                  '@'   => 'PRP' }}}},
                         'adj'  => { 'numtype' => { 'ord' => 'QO',
                                                    '@'   => { 'prontype' => { 'dem' => 'DEM',
                                                                               'ind' => 'QF',
                                                                               'tot' => 'QF',
                                                                               'neg' => 'QF',
                                                                               '@'   => 'JJ' }}}},
                         'num'  => 'QC',
                         'verb' => { 'verbtype' => { 'aux' => 'VAUX',
                                                     '@'   => 'VM' }},
                         'adv'  => 'RB',
                         'adp'  => 'PSP',
                         'conj' => 'CC',
                         'part' => { 'prontype' => { 'neg' => 'NEG',
                                                     '@'   => 'RP' }},
                         'int'  => 'INJ',
                         'punc' => 'SYM',
                         '@'    => { 'echo' => { 'rdp' => 'RDP',
                                                 '@'   => { 'other/pos' => { 'null' => 'NULL',
                                                                             '@'    => 'XC' }}}}}}
    );
    # GENDER ####################
    $atoms{gend} = $self->create_simple_atom
    (
        'intfeature' => 'gender',
        'simple_decode_map' =>
        {
            'm' => 'masc',
            'f' => 'fem',
            'n' => 'neut'
        }
    );
    # NUMBER ####################
    $atoms{num} = $self->create_simple_atom
    (
        'intfeature' => 'number',
        'simple_decode_map' =>
        {
            'sg'   => 'sing',
            'pl'   => 'plur',
            'dual' => 'dual'
        }
    );
    # PERSON ####################
    $atoms{pers} = $self->create_atom
    (
        'tagset' => 'bn::conll',
        'surfeature' => 'person',
        'decode_map' =>
        {
            '1'   => ['person' => '1'],
            '2'   => ['person' => '2'],
            '3'   => ['person' => '3'],
            ###!!! There are also pers-4, pers-5, pers-6 and pers-7. So far I have not been able to figure out what these values mean.
            '4'   => ['other' => {'person' => '4'}],
            '5'   => ['other' => {'person' => '5'}],
            '6'   => ['other' => {'person' => '6'}],
            '7'   => ['other' => {'person' => '7'}],
            'any' => ['person' => '1|2|3']
        },
        'encode_map' =>

            { 'other/person' => { '4' => '4',
                                  '5' => '5',
                                  '6' => '6',
                                  '7' => '7',
                                  '@' => { 'person' => { '1|2|3' => 'any',
                                                         '1'     => '1',
                                                         '2'     => '2',
                                                         '3'     => '3' }}}}
    );
    # CASE ####################
    $atoms{case} = $self->create_simple_atom
    (
        'intfeature' => 'case',
        'simple_decode_map' =>
        {
            'd' => 'nom', # direct
            'o' => 'acc'  # oblique
        }
    );
    # VOICE ####################
    $atoms{voicetype} = $self->create_simple_atom
    (
        'intfeature' => 'voice',
        'simple_decode_map' =>
        {
            'active'  => 'act',
            'passive' => 'pass'
        }
    );
    return \%atoms;
}



#------------------------------------------------------------------------------
# Decodes a physical tag (string) and returns the corresponding feature
# structure.
#------------------------------------------------------------------------------
sub decode
{
    my $self = shift;
    my $tag = shift;
    my $fs = Lingua::Interset::FeatureStructure->new();
    $fs->set_tagset('hi::conll');
    my $atoms = $self->atoms();
    # Two components: part of speech and features
    # Hindi CoNLL files are converted from the Shakti Standard Format.
    # The CPOS column contains the chunk tag and is not considered part of the tag for this driver.
    # The POS column contains part of speech of the chunk headword.
    # example: NN\tcat-n|gend-|num-sg|pers-|case-d|vib-0|tam-0
    my ($pos, $features) = split(/\s+/, $tag);
    $features = '' if($features eq '_');
    my @features_conll = split(/\|/, $features);
    my %features_conll;
    foreach my $f (@features_conll)
    {
        if($f =~ m/^(\w+)-(.+)$/)
        {
            $features_conll{$1} = $2;
        }
        else
        {
            $features_conll{$f} = $f;
        }
    }
    $atoms->{pos}->decode_and_merge_hard($pos, $fs);
    foreach my $name ('gend', 'num', 'pers', 'case')
    {
        if(defined($features_conll{$name}) && $features_conll{$name} ne '')
        {
            $atoms->{$name}->decode_and_merge_hard($features_conll{$name}, $fs);
        }
    }
    ###!!! Proper decoding of vibhakti and tense-aspect-modality is not implemented yet.
    ###!!! A slévání podrysů při plnění other by mělo být k dispozici už ve FeatureStructure, teď je to jen v Atomu, takže to tady nemůžu použít, grr!!!
    my %othervibtam;
    my $ovt_nonempty = 0;
    my $other = $fs->other();
    if(defined($other) && ref($other) eq 'HASH' && scalar(keys(%{$other})))
    {
        %othervibtam = %{$other};
    }
    if(defined($features_conll{vib}) && $features_conll{vib} ne '')
    {
        $othervibtam{vib} = $features_conll{vib};
        $ovt_nonempty = 1;
    }
    if(defined($features_conll{tam}) && $features_conll{tam} ne '')
    {
        $othervibtam{tam} = $features_conll{tam};
        $ovt_nonempty = 1;
    }
    if($ovt_nonempty)
    {
        $fs->set('other', \%othervibtam);
    }
    return $fs;
}



#------------------------------------------------------------------------------
# Takes feature structure and returns the corresponding physical tag (string).
#------------------------------------------------------------------------------
sub encode
{
    my $self = shift;
    my $fs = shift; # Lingua::Interset::FeatureStructure
    my $atoms = $self->atoms();
    my $pos = $atoms->{pos}->encode($fs);
    my @feature_names = ('gend', 'num', 'pers', 'case', 'vib', 'tam');
    my @features;
    foreach my $name (@feature_names)
    {
        my $value = '';
        if($name =~ m/^(vib|tam)$/)
        {
            $value = $fs->get_other_subfeature('bn::conll', $name);
        }
        else
        {
            if(!defined($atoms->{$name}))
            {
                confess("Cannot find atom for '$name'");
            }
            $value = $atoms->{$name}->encode($fs);
        }
        # The Hyderabad CoNLL files always name all features including those with empty values.
        push(@features, "$name-$value");
    }
    my $features = '_';
    if(scalar(@features) > 0)
    {
        $features = join('|', @features);
    }
    my $tag = "$pos\t$features";
    return $tag;
}



#------------------------------------------------------------------------------
# Returns reference to list of known tags. These are tag occurrences collected
# from the corpus, i.e. other tags probably exist but were not seen here. We
# have added manually tags with empty 'vib' and 'tam' to facilitate generating
# permitted tags with empty 'other' feature.
# 531 tags
#------------------------------------------------------------------------------
sub list
{
    my $self = shift;
    my $list = <<end_of_list
end_of_list
    ;
    # Protect from editors that replace tabs by spaces.
    $list =~ s/ \s+/\t/sg;
    my @list = split(/\r?\n/, $list);
    return \@list;
}



1;

=head1 SYNOPSIS

  use Lingua::Interset::Tagset::HI::Conll;
  my $driver = Lingua::Interset::Tagset::HI::Conll->new();
  my $fs = $driver->decode("NN\tcat-n|gend-|num-sg|pers-|case-d|vib-0|tam-0");

or

  use Lingua::Interset qw(decode);
  my $fs = decode('hi::conll', "NN\tcat-n|gend-|num-sg|pers-|case-d|vib-0|tam-0");

=head1 DESCRIPTION

Interset driver for the Hindi tagset of the ICON 2009 and 2010 Shared Tasks,
as used in the CoNLL data format.
CoNLL tagsets in Interset are traditionally three values separated by tabs,
coming from the CoNLL columns CPOS, POS and FEAT.
ICON shared task data were converted to CoNLL from the native Shakti Standard Format (SSF).
The CoNLL CPOS column contains so-called chunk tag, which we do not want to decode,
thus we expect only two tab-separated values in this tagset:
the POS column (which contains the part of speech of the headword of the chunk)
and partial contents of the FEAT column (we exclude features that should not be
considered part of the tag,
e.g. the C<lex> feature, which contains lemma or word stem).

Short description of the part of speech tags can be found in
L<http://ltrc.iiit.ac.in/nlptools2010/documentation.php>.
More information is available in the annotators' manual at
L<http://ltrc.iiit.ac.in/MachineTrans/publications/technicalReports/tr031/posguidelines.pdf>.

=head1 SEE ALSO

L<Lingua::Interset>,
L<Lingua::Interset::Tagset>,
L<Lingua::Interset::FeatureStructure>

=cut
