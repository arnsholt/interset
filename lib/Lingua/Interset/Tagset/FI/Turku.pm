# ABSTRACT: Driver for the Finnish tagset from the Turku Dependency Treebank.
# Tag is a sequence of features separated by vertical bars. There are just the feature values, not attribute-value pairs.
# Copyright © 2011, 2014 Dan Zeman <zeman@ufal.mff.cuni.cz>

package Lingua::Interset::Tagset::FI::Turku;
use strict;
use warnings;
# VERSION: generated by DZP::OurPkgVersion

use utf8;
use open ':utf8';
use namespace::autoclean;
use Moose;
extends 'Lingua::Interset::Tagset';



has 'atoms' => ( isa => 'HashRef', is => 'ro', builder => '_create_atoms', lazy => 1 );



#------------------------------------------------------------------------------
# Returns the tagset id that should be set as the value of the 'tagset' feature
# during decoding. Every derived class must (re)define this method! The result
# should correspond to the last two parts in package name, lowercased.
# Specifically, it should be the ISO 639-2 language code, followed by '::' and
# a language-specific tagset id. Example: 'cs::multext'.
#------------------------------------------------------------------------------
sub get_tagset_id
{
    return 'fi::turku';
}



#------------------------------------------------------------------------------
# Creates atomic drivers for surface features.
#------------------------------------------------------------------------------
sub _create_atoms
{
    my $self = shift;
    my %atoms;
    # PART OF SPEECH ####################
    $atoms{pos} = $self->create_atom
    (
        'tagset' => 'fi::turku',
        'surfeature' => 'pos',
        'decode_map' =>
        {
            # n = noun (tuul, mees, kraan, riik, naine)
            'n' => ['pos' => 'noun', 'nountype' => 'com'],
            # prop = proper noun (Arnold, Lennart, Palts, Savisaar, Telia)
            'prop' => ['pos' => 'noun', 'nountype' => 'prop'],
            # art = article ###!!! DOES NOT OCCUR IN THE CORPUS
            'art' => ['pos' => 'adj', 'prontype' => 'art'],
            # v = verb (kutsutud, tahtnud, teadnud, tasunud, polnud)
            'v' => ['pos' => 'verb'],
            # v-fin = finite verb (roniti, valati, sõidutati, lahkunud, prantsatasimegi)
            'v-fin' => ['pos' => 'verb', 'verbform' => 'fin'],
            # v-inf = infinitive?/non-finite verb (lugeda, nuusutada, kiirustamata, laulmast, magama)
            'v-inf' => ['pos' => 'verb', 'verbform' => 'inf'],
            # v-pcp2 = verb participle? (sõidutatud, liigutatud, sisenenud, sõudnud, prantsatatud)
            'v-pcp2' => ['pos' => 'verb', 'verbform' => 'part'],
            # adj = adjective (suur, väike, noor, aastane, hall)
            'adj' => ['pos' => 'adj'],
            # adj-nat = nationality adjective (prantsuse, tšuktši)
            'adj-nat' => ['pos' => 'adj', 'nountype' => 'prop', 'nametype' => 'nat'],
            # adv = adverb (välja, edasi, ka, siis, maha)
            'adv' => ['pos' => 'adv'],
            # prp = preposition (juurde, taga, all, vastu, kohta)
            'prp' => ['pos' => 'adp', 'adpostype' => 'prep'],
            # pst = preposition/postposition (poole, järele, juurde, pealt, peale)
            'pst' => ['pos' => 'adp', 'adpostype' => 'post'],
            # conj-s = subordinating conjunction (et, kui, sest, nagu, kuigi)
            'conj-s' => ['pos' => 'conj', 'conjtype' => 'sub'],
            # conj-c = coordinating conjunction (ja, aga, või, vaid, a)
            'conj-c' => ['pos' => 'conj', 'conjtype' => 'coor'],
            # conj-p = prepositional conjunction ??? ###!!! DOES NOT OCCUR IN THE CORPUS
            'conj-p' => ['pos' => 'conj', 'other' => {'subpos' => 'prep'}],
            # pron = pronoun (to be specified) (pronoun type may be specified using features) (nood, sel, niisugusest, selle, sellesama)
            'pron' => ['pos' => 'noun', 'prontype' => 'prn'],
            # pron-pers = personal pronoun (ma, mina, sa, ta, tema, me, nad, nemad)
            'pron-pers' => ['pos' => 'noun', 'prontype' => 'prs'],
            # pron-rel = relative pronoun (mis, kes)
            'pron-rel' => ['pos' => 'noun', 'prontype' => 'rel'],
            # pron-int = interrogative pronoun ###!!! DOES NOT OCCUR IN THE CORPUS (is included under relative pronouns)
            'pron-int' => ['pos' => 'noun', 'prontype' => 'int'],
            # pron-dem = demonstrative pronoun (see, üks, siuke, selline, too)
            'pron-dem' => ['pos' => 'noun', 'prontype' => 'dem'],
            # pron-indef = indefinite pronoun (mõned)
            'pron-indef' => ['pos' => 'noun', 'prontype' => 'ind'],
            # pron-poss = possessive pronoun (ise)
            'pron-poss' => ['pos' => 'noun', 'prontype' => 'prs', 'poss' => 'poss'],
            # pron-def = possessive (?) pronoun (keegi, mingi)
            'pron-def' => ['pos' => 'noun', 'prontype' => 'prs', 'poss' => 'poss'],
            # pron-refl = reflexive pronoun (enda, endasse)
            'pron-refl' => ['pos' => 'noun', 'prontype' => 'prs', 'reflex' => 'reflex'],
            # num = numeral (kaks, neli, viis, seitse, kümme)
            'num' => ['pos' => 'num'],
            # intj = interjection (no, kurat)
            'intj' => ['pos' => 'int'],
            # infm = infinitive marker ###!!! DOES NOT OCCUR IN THE CORPUS
            'infm' => ['pos' => 'part', 'parttype' => 'inf'],
            # punc = punctuation (., ,, ', -, :)
            'punc' => ['pos' => 'punc'],
            # sta = statement ??? ###!!! DOES NOT OCCUR IN THE CORPUS
            # abbr = abbreviation (km/h, cm)
            'abbr' => ['abbr' => 'abbr'],
            # x = undefined word class (--, pid, viis-, ta-)
            'x' => [],
            # b = discourse particle (only in sul.xml (spoken language)) (noh, nigu, vä, nagu, ei)
            'b' => ['pos' => 'part']
        },
        'encode_map' =>

            { 'prontype' => { ''    => { 'pos' => { 'noun' => { 'nountype' => { 'prop' => 'prop',
                                                                                '@'    => 'n' }},
                                                    'adj'  => { 'nametype' => { 'nat' => 'adj-nat',
                                                                                '@'   => 'adj' }},
                                                    'num'  => 'num',
                                                    # Encoding of verb forms is inconsistent in the corpus.
                                                    # The form is encoded in the features but sometimes it is also part of the part-of-speech tag.
                                                    # We can decode v-(fin|inf|pcp2) but we do not encode it.
                                                    # Our list of known tags only contains the simple "v" variant.
                                                    'verb' => 'v',
                                                    'adv'  => 'adv',
                                                    'adp'  => { 'adpostype' => { 'post' => 'pst',
                                                                                 '@'    => 'prp' }},
                                                    'conj' => { 'conjtype' => { 'sub' => 'conj-s',
                                                                                '@'   => 'conj-c' }},
                                                    'part' => { 'parttype' => { 'inf' => 'infm',
                                                                                '@'   => 'b' }},
                                                    'int'  => 'intj',
                                                    'punc' => 'punc',
                                                    '@'    => { 'abbr' => { 'abbr' => 'abbr',
                                                                            '@'    => 'x' }}}},
                              'art' => 'art',
                              # Encoding of pronoun types is inconsistent in the corpus.
                              # The type is always the first feature but sometimes it is also part of the part-of-speech tag (pron-dem/dem), next time it is not (pron/dem).
                              # We can decode pron-(dem|indef|int|rel) but we do not encode it. Our list of known tags only contains the pron/dem variant.
                              '@'   => 'pron' }}
    );
    # NOUNTYPE ####################
    $atoms{nountype} = $self->create_atom
    (
        'surfeature' => 'nountype',
        'decode_map' =>
        {
            # com ... common noun (tuul, mees, kraan, riik, naine)
            'com'     => ['nountype' => 'com'],
            # prop ... proper noun (Peeter, Jaan, Jüri, Mare, Erik)
            'prop'    => ['nountype' => 'prop'],
            # nominal ... nominal abbreviation (Kaabel-TV, EE, kaabelTV) ... used rarely and inconsistently, should be ignored
            'nominal' => []
        },
        'encode_map' =>
        {
            'nountype' => { 'prop' => 'prop',
                            '@'    => 'com' }
        }
    );
    return \%atoms;
}



#------------------------------------------------------------------------------
# Decodes a physical tag (string) and returns the corresponding feature
# structure.
#------------------------------------------------------------------------------
sub decode
{
    my $self = shift;
    my $tag = shift;
    my $fs = Lingua::Interset::FeatureStructure->new();
    $fs->set_tagset('fi::turku');
    my $atoms = $self->atoms();
    # Tag is a sequence of features separated by vertical bars.
    # There are just the feature values, not attribute-value pairs.
    # example: n/com,sg,nom ###!!! replace the Estonian example by a Finnish one
    my @features = split(/\|/, $tag);
    foreach my $feature (@features)
    {
        $atoms->{feature}->decode_and_merge_hard($feature, $fs);
    }
    return $fs;
}



#------------------------------------------------------------------------------
# Takes feature structure and returns the corresponding physical tag (string).
#------------------------------------------------------------------------------
sub encode
{
    ###!!! Dodělat. Tohle je zatím jen kopie estonského encode().
    my $self = shift;
    my $fs = shift; # Lingua::Interset::FeatureStructure
    my $atoms = $self->atoms();
    my $pos = $atoms->{pos}->encode($fs);
    my $features = '--';
    my %feature_names =
    (
        'n'     => ['nountype', 'number', 'case'],
        'prop'  => ['nountype', 'number', 'case'],
        'aord'  => ['numtype', 'number', 'case', 'numform'],
        'apart' => ['degree', 'number', 'case', 'mood'],
        'adj'   => ['degree', 'number', 'case'],
        'prs'   => ['prontype', 'person', 'number', 'case'],
        'pron'  => ['prontype', 'number', 'case'],
        'num'   => ['numtype', 'number', 'case', 'numform'],
        'vinf'  => ['verbtype', 'mood'],
        'vpart' => ['verbtype', 'mood', 'tense', 'person', 'number', 'personal'],
        'vsup'  => ['verbtype', 'mood', 'person', 'number', 'personal', 'case'],
        'v'     => ['verbtype', 'mood', 'tense', 'person', 'number', 'personal', 'negativeness'],
        'prp'   => ['adpostype', 'valcase'],
        'pst'   => ['adpostype', 'valcase'],
        'conj-c'=> ['conjtype'],
        'conj-s'=> ['conjtype'],
        'punc'  => ['punctype']
    );
    my $fpos = $pos;
    $fpos = 'aord'  if($fpos eq 'adj' && $fs->is_ordinal());
    $fpos = 'apart' if($fpos eq 'adj' && $fs->is_participle());
    $fpos = 'prs'   if($fpos eq 'pron' && $fs->is_personal_pronoun() && !$fs->is_possessive() && !$fs->is_reflexive());
    $fpos = 'vinf'  if($fpos eq 'v' && ($fs->is_infinitive() || $fs->is_gerund()));
    $fpos = 'vpart' if($fpos eq 'v' && ($fs->is_participle() || $fs->is_transgressive()));
    $fpos = 'vsup'  if($fpos eq 'v' && $fs->is_supine());
    my $feature_names = $feature_names{$fpos};
    $feature_names = [] unless(defined($feature_names));
    my @features = ();
    foreach my $feature (@{$feature_names})
    {
        my $value = $atoms->{$feature}->encode($fs);
        push(@features, $value) unless($value eq '');
    }
    if(@features)
    {
        $features = join(',', @features);
    }
    my $tag = "$pos/$features";
    return $tag;
}



#------------------------------------------------------------------------------
# Returns reference to list of known tags.
# Tags were collected from the corpus.
# 598 tags have been observed in the corpus.
# We removed some tags due to inconsistency between pos and features (e.g.
# conj-c/sub).
# Removed features:
# .cap, %cap ... the word starts with an uppercase letter
# 252 tags survived.
# Then we added missing combinations of number+case (except for the additive
# case, whose usage is limited) for nominals and person+number for verbs.
# 614 total tags after the extension.
#------------------------------------------------------------------------------
sub list
{
    my $self = shift;
    my $list = <<end_of_list
end_of_list
    ;
    # Protect from editors that replace tabs by spaces.
    $list =~ s/[ \t]+/\t/sg;
    my @list = split(/\r?\n/, $list);
    return \@list;
}



1;

=head1 SYNOPSIS

  use Lingua::Interset::Tagset::FI::Turku;
  my $driver = Lingua::Interset::Tagset::FI::Turku->new();
  my $fs = $driver->decode('n/com,sg,nom'); ###!!! finský příklad podstatného jména

or

  use Lingua::Interset qw(decode);
  my $fs = decode('fi::turku', 'n/com,sg,nom'); ###!!! finský příklad podstatného jména

=head1 DESCRIPTION

Interset driver for the Finnish tagset from the Turku Dependency Treebank.
Tag is a sequence of features separated by vertical bars.
There are just the feature values, not attribute-value pairs.

=head1 SEE ALSO

L<Lingua::Interset>,
L<Lingua::Interset::Tagset>,
L<Lingua::Interset::FeatureStructure>

=cut
