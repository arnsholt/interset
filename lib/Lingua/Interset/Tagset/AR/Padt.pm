# ABSTRACT: Driver for the PADT 2.0 / ElixirFM Arabic positional tagset.
# Copyright Â© 2013, 2014 Dan Zeman <zeman@ufal.mff.cuni.cz>

package Lingua::Interset::Tagset::AR::Padt;
use strict;
use warnings;
# VERSION: generated by DZP::OurPkgVersion

use utf8;
use open ':utf8';
use namespace::autoclean;
use Moose;
extends 'Lingua::Interset::Tagset';



has 'atoms' => ( isa => 'HashRef', is => 'ro', builder => '_create_atoms', lazy => 1 );



#------------------------------------------------------------------------------
# Creates atomic drivers for surface features.
#------------------------------------------------------------------------------
sub _create_atoms
{
    my $self = shift;
    my %atoms;
    # PART OF SPEECH ####################
    $atoms{pos} = $self->create_atom
    (
        'tagset' => 'ar::padt',
        'surfeature' => 'pos',
        'decode_map' =>
        {
            # common noun
            'N-' => ['pos' => 'noun', 'nountype' => 'com'],
            # proper noun
            'Z-' => ['pos' => 'noun', 'nountype' => 'prop'],
            # adjective
            'A-' => ['pos' => 'adj'],
            # pronoun (probably personal)
            'S-' => ['pos' => 'noun|adj', 'prontype' => 'prs'],
            # personal pronoun
            'SP' => ['pos' => 'noun', 'prontype' => 'prs'],
            # demonstrative pronoun
            'SD' => ['pos' => 'noun|adj', 'prontype' => 'dem'],
            # relative pronoun
            'SR' => ['pos' => 'noun|adj', 'prontype' => 'rel'],
            # numeral: number
            'Q-' => ['pos' => 'num', 'numform' => 'digit'],
            # numeral: hundred
            'QC' => ['pos' => 'num', 'numform' => 'word', 'other' => {'numvalue' => 100}],
            # numeral: one
            'QI' => ['pos' => 'num', 'numform' => 'word', 'numvalue' => '1'],
            # numeral: twenty, thirty, ..., ninety
            'QL' => ['pos' => 'num', 'numform' => 'word', 'other' => {'numvalue' => 20}],
            # numeral: thousand, million, billion, ...
            'QM' => ['pos' => 'num', 'numform' => 'word', 'other' => {'numvalue' => 1000}],
            # numeral: -teen
            'QU' => ['pos' => 'num', 'numform' => 'word', 'other' => {'numvalue' => 15}],
            # numeral: three, four, ..., nine
            'QV' => ['pos' => 'num', 'numform' => 'word', 'numvalue' => '3'],
            # numeral: ten
            'QX' => ['pos' => 'num', 'numform' => 'word', 'other' => {'numvalue' => 10}],
            # numeral: two
            'QY' => ['pos' => 'num', 'numform' => 'word', 'numvalue' => '2'],
            # verb
            'V-' => ['pos' => 'verb'],
            'VI' => ['pos' => 'verb', 'aspect' => 'imp'],
            'VP' => ['pos' => 'verb', 'aspect' => 'perf'],
            'VC' => ['pos' => 'verb', 'verbform' => 'fin', 'mood' => 'imp'],
            # adverb
            'D-' => ['pos' => 'adv'],
            # preposition
            'P-' => ['pos' => 'adp', 'adpostype' => 'prep'],
            # inflected preposition (nominative, genitive, accusative)
            'PI' => ['pos' => 'adp', 'adpostype' => 'prep'],
            # conjunction
            'C-' => ['pos' => 'conj'],
            # function word, particle
            'F-' => ['pos' => 'part'],
            # interrogative particle
            'FI' => ['pos' => 'part', 'prontype' => 'int'],
            # negative particle
            'FN' => ['pos' => 'part', 'negativeness' => 'neg'],
            # interjection
            'I-' => ['pos' => 'int'],
            # abbreviation
            'Y-' => ['abbr' => 'abbr'],
            # typo
            'T-' => ['typo' => 'typo'],
            # punctuation (not used in UMH subcorpus)
            'G-' => ['pos' => 'punc'],
            # non-Arabic script
            'X-' => ['foreign' => 'foreign'],
            # residual class for unknown words
            'U-' => [],
            # if empty tag occurs treat it as unknown word
            '_' => []
        },
        'encode_map' =>

            { 'abbr' => { 'abbr' => 'Y-',
                 '@'    => { 'typo' => { 'typo' => 'T-',
                                '@'    => { 'numtype' => { ''  => { 'pos' => { 'noun' => { 'prontype' => { ''    => { 'nountype' => { 'prop' => 'Z-',
                                                                                                                                      '@'    => 'N-' }},
                                                                                                           'prs' => 'SP',
                                                                                                           'dem' => 'SD',
                                                                                                           'rel' => 'SR',
                                                                                                           '@'   => 'S-' }},
                                                                               'adj'  => { 'prontype' => { ''    => { 'adjtype' => { 'art' => '--',
                                                                                                                                     '@'   => 'A-' }},
                                                                                                           'dem' => 'SD',
                                                                                                           'rel' => 'SR',
                                                                                                           '@'   => 'S-' }},
                                                                               'num'  => { 'numform' => { 'word' => { 'other/numvalue' => { 10   => 'QX',
                                                                                                                                            15   => 'QU',
                                                                                                                                            20   => 'QL',
                                                                                                                                            100  => 'QC',
                                                                                                                                            1000 => 'QM',
                                                                                                                                            '@'  => { 'numvalue' => { '1' => 'QI',
                                                                                                                                                                      '2' => 'QY',
                                                                                                                                                                      '3' => 'QV',
                                                                                                                                                                      '@' => 'Q-' }}}},
                                                                                                          '@'    => 'Q-' }},
                                                                               'verb' => { 'mood' => { 'imp' => 'VC',
                                                                                                       '@'   => { 'aspect' => { 'perf' => 'VP',
                                                                                                                                '@'    => 'VI' }}}},
                                                                               'adv'  => 'D-',
                                                                               'adp'  => 'P-',
                                                                               'conj' => 'C-',
                                                                               'part' => { 'prontype' => { 'int' => 'FI',
                                                                                                           '@'   => { 'negativeness' => { 'neg' => 'FN',
                                                                                                                                          '@'   => 'F-' }}}},
                                                                               'int'  => 'I-',
                                                                               'punc' => 'G-',
                                                                               '@'    => '_' }},
                                                           '@' => 'Q-' }}}}}}
    );
    # GENDER ####################
    $atoms{gender} = $self->create_simple_atom
    (
        'intfeature' => 'gender',
        'simple_decode_map' =>
        {
            'M' => 'masc',
            'F' => 'fem'
        },
        'encode_default' => '-'
    );
    # NUMBER ####################
    $atoms{number} = $self->create_simple_atom
    (
        'intfeature' => 'number',
        'simple_decode_map' =>
        {
            'S' => 'sing',
            'D' => 'dual',
            'P' => 'plu'
        },
        'encode_default' => '-'
    );
    # CASE ####################
    $atoms{case} = $self->create_simple_atom
    (
        'intfeature' => 'case',
        'simple_decode_map' =>
        {
            '1' => 'nom',
            '2' => 'gen',
            '4' => 'acc'
        },
        'encode_default' => '-'
    );
    # DEFINITENESS ####################
    $atoms{definiteness} = $self->create_simple_atom
    (
        'intfeature' => 'definiteness',
        'simple_decode_map' =>
        {
            # definite
            'D' => 'def',
            # indefinite
            'I' => 'ind',
            # reduced
            'R' => 'red',
            # complex
            'C' => 'com'
        },
        'encode_default' => '-'
    );
    # PERSON ####################
    $atoms{person} = $self->create_simple_atom
    (
        'intfeature' => 'person',
        'simple_decode_map' =>
        {
            '1' => '1',
            '2' => '2',
            '3' => '3'
        },
        'encode_default' => '-'
    );
    # MOOD ####################
    $atoms{mood} = $self->create_atom
    (
        'surfeature' => 'mood',
        'decode_map' =>
        {
            'I' => ['verbform' => 'fin', 'mood' => 'ind'],
            'S' => ['verbform' => 'fin', 'mood' => 'sub'],
            'J' => ['verbform' => 'fin', 'mood' => 'jus'],
            # undecided between subjunctive and jussive
            'D' => ['verbform' => 'fin', 'mood' => 'sub|jus']
        },
        'encode_map' =>

            { 'mood' => { 'jus|sub' => 'D',
                          'sub'     => 'S',
                          'jus'     => 'J',
                          'ind'     => 'I',
                          '@'       => '-' }}
    );
    # VOICE ####################
    $atoms{voice} = $self->create_simple_atom
    (
        'intfeature' => 'voice',
        'simple_decode_map' =>
        {
            'A' => 'act',
            'P' => 'pass'
        },
        'encode_default' => '-'
    );
    return \%atoms;
}



#------------------------------------------------------------------------------
# Decodes a physical tag (string) and returns the corresponding feature
# structure.
#------------------------------------------------------------------------------
sub decode
{
    my $self = shift;
    my $tag = shift;
    my $fs = Lingua::Interset::FeatureStructure->new();
    $fs->set_tagset('ar::padt');
    my $atoms = $self->atoms();
    # The tags are positional, there are 10 character positions:
    # pos subpos mood voice ??? pers gen num case def
    # example: N-------1I
    my @chars = split(//, $tag);
    my @features = ('pos', 'subpos', 'mood', 'voice', undef, 'person', 'gender', 'number', 'case', 'definiteness');
    for(my $i = 0; $i<=$#chars; $i++)
    {
        next if(!defined($features[$i]));
        my $feature = $features[$i];
        my $value = $chars[$i];
        $value .= $chars[++$i] if($i==0);
        $atoms->{$feature}->decode_and_merge_hard($value, $fs);
    }
    return $fs;
}



#------------------------------------------------------------------------------
# Takes feature structure and returns the corresponding physical tag (string).
#------------------------------------------------------------------------------
sub encode
{
    my $self = shift;
    my $fs = shift; # Lingua::Interset::FeatureStructure
    my $atoms = $self->atoms();
    my @features = ('pos', 'subpos', 'mood', 'voice', undef, 'person', 'gender', 'number', 'case', 'definiteness');
    my $tag = $atoms->{pos}->encode($fs);
    for(my $i = 2; $i<=$#features; $i++)
    {
        my $feature = $features[$i];
        my $value = '-';
        if(defined($feature))
        {
            $value = $atoms->{$feature}->encode($fs);
        }
        $tag .= $value;
    }
    return $tag;
}



#------------------------------------------------------------------------------
# Returns reference to list of known tags.
# 296 tags
#------------------------------------------------------------------------------
sub list
{
    my $self = shift;
    my $list = <<end_of_list
end_of_list
    ;
    # Protect from editors that replace tabs by spaces.
    $list =~ s/ \s+/\t/sg;
    my @list = split(/\r?\n/, $list);
    return \@list;
}



1;

=head1 SYNOPSIS

  use Lingua::Interset::Tagset::AR::Padt;
  my $driver = Lingua::Interset::Tagset::AR::Padt->new();
  my $fs = $driver->decode('N-------1I');

or

  use Lingua::Interset qw(decode);
  my $fs = decode('ar::padt', 'N-------1I');

=head1 DESCRIPTION

# ABSTRACT: Driver for the PADT 2.0 / ElixirFM Arabic positional tagset.
Interset driver for the Arabic tagset of the Prague Arabic Dependency Treebank
(PADT) 2.0. The same tagset is also used by the ElixirFM Arabic morphological
analyzer. It is a positional tagset. Every tag consists of 10 characters and
the position of the character in the tag determines its interpretation:
I<pos, subpos, mood, voice, RESERVED, person, gender, number, case, definiteness.>

=head1 SEE ALSO

L<Lingua::Interset>,
L<Lingua::Interset::Tagset>,
L<Lingua::Interset::Tagset::AR::Conll>,
L<Lingua::Interset::Tagset::AR::Conll2007>,
L<Lingua::Interset::FeatureStructure>

=cut
