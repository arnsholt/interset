# ABSTRACT: Atomic driver for a surface feature.
# Copyright © 2014 Dan Zeman <zeman@ufal.mff.cuni.cz>

package Lingua::Interset::Atom;
use strict;
use warnings;
# VERSION: generated by DZP::OurPkgVersion

use utf8;
use open ':utf8';
use namespace::autoclean;
use Moose;
use Lingua::Interset;
use Lingua::Interset::FeatureStructure;
extends 'Lingua::Interset::Tagset';



has 'feature' => ( isa => 'Str', is => 'ro', required => 1, documentation => 'Name of the surface feature the atom describes.' );
# Example of a decoding map:
# { 'M' => ['gender' => 'masc', 'animateness' => 'anim'],
#   'I' => ['gender' => 'masc', 'animateness' => 'inan'],
#   'F' => ['gender' => 'fem'],
#   'N' => ['gender' => 'neut'] }
has 'decode_map' => ( isa => 'HashRef', is => 'ro', required => 1 );
# Example of an encoding map:
# The top-level hash must have just one key, a name of a known feature (it is a hash for cosmetic reasons).
# '@' denotes the default and will be translated to an else block
# { 'gender' => { 'masc' => { 'animateness' => { 'inan' => 'I',
#                                                '@'    => 'M' }},
#                 'fem'  => 'F',
#                 '@'    => 'N' }}
has 'encode_map' => ( isa => 'HashRef', is => 'ro', required => 1 );



#------------------------------------------------------------------------------
# Decodes a physical tag (string) and returns the corresponding feature
# structure.
#------------------------------------------------------------------------------
=method decode()

  my $fs  = $driver->decode ($tag);

Takes a tag (string) and returns a L<Lingua::Interset::FeatureStructure> object
with corresponding feature values set.

=cut
sub decode
{
    my $self = shift;
    my $tag = shift;
    my $fs = Lingua::Interset::FeatureStructure->new();
    my $map = $self->decode_map();
    my $assignments = $map->{$tag};
    if($assignments)
    {
        $fs->multiset(@{$assignments});
    }
    return $fs;
}



#------------------------------------------------------------------------------
# Takes feature structure and returns the corresponding physical tag (string).
#------------------------------------------------------------------------------
=method encode()

  my $tag = $driver->encode ($fs);

Takes a L<Lingua::Interset::FeatureStructure> object and
returns the tag (string) in the given tagset that corresponds to the feature values.
Note that some features may be ignored because they cannot be represented
in the given tagset.

=cut
sub encode
{
    my $self = shift;
    my $fs = shift; # Lingua::Interset::FeatureStructure
    my $fs_hash = $fs->get_hash();
    translate($fs_hash, 21);
    # Call non-strict ("1") encoding of the old driver. We use a different method ("encode_strict") for strict encoding now.
    my $tag = &{$self->encode_function()}($fs_hash, 1);
    return $tag;
}



#------------------------------------------------------------------------------
# Returns reference to list of known tags.
#------------------------------------------------------------------------------
=method list()

  my $list_of_tags = $driver->list();

Returns the reference to the list of all known tags in this particular tagset.
This is not directly needed to decode, encode or convert tags but it is very useful
for testing and advanced operations over the tagset.
Note however that many tagset drivers contain only an approximate list,
created by collecting tag occurrences in some corpus.

=cut
sub list
{
    my $self = shift;
    return &{$self->list_function()}();
}



1;

=head1 SYNOPSIS

  use Lingua::Interset::Atom;

=head1 DESCRIPTION

Atom is a special case of a tagset driver.
As the name suggests, the surface tags are considered atomic, i.e. indivisible.
It provides environment for easy mapping between surface strings and Interset features.

While Atom can be used to implement drivers of tagsets whose tags are not structured
(such as en::penn or sv::mamba), they should also provide means of defining
“sub-drivers” for individual surface features within drivers of complex tagsets.
For example, the Czech tags in the Prague Dependency Treebank are always strings
of 15 characters where I<i>-th position in the string encodes I<i>-th surface feature
(which may or may not directly correspond to a feature in Interset).
A driver for the PDT tagset could internally construct atomic drivers for PDT
gender, number, case etc.

=head1 SEE ALSO

L<Lingua::Interset::Tagset>,
L<Lingua::Interset::FeatureStructure>

=cut
